
/** 
 * RealMap Heatmap v1.1.1
 * Copyright (C) 2023-2025 WooriTech Inc.
 * All Rights Reserved. 
 */
import{HeatmapSeriesType as e,extend as t,MarkerSeries as i,Color as s,MarkerSeriesPoint as r,parseCoord as l,maxv as o,pickNum as n,pickProp as a,floor as h,MarkerSeriesView as d,RmElement as p,SeriesView as c,PointViewPool as _,SeriesAnimation as g,MarkerSeriesPointView as u}from"./realmap.1.1.1.mjs";class m extends r{_readObject(e,t){super._readObject(e,t)}}const C={count:e=>e.length,sum:e=>e.map((e=>e.getValue())).reduce(((e,t)=>e+t)),avg:e=>e.map((e=>e.getValue())).reduce(((e,t)=>e+t))/e.length};class f{_apply(e){this.origin=l(e.origin),this.cellWidth=+e.cellWidth,this.cellHeight=+e.cellWidth,isNaN(this.cellHeight)&&(this.cellHeight=o(60,n(this.cellWidth,3600))),isNaN(this.cellWidth)&&(this.cellWidth=this.cellHeight),this.blur=o(0,n(e.blur,0)),this.aggregation=a(e.aggregation,"sum")}buildCells(e){const t={},i=this.origin[0],s=this.origin[1],r=this.cellWidth,l=this.cellHeight;e.forEach((e=>{if(e.visible){const o=h(3600*(e.lon-i)/r),n=h(3600*(e.lat-s)/l),a=`${o}+${n}`;let d=t[a];d?d.points.push(e):t[a]={lon:o*r/3600,lat:n*l/3600,points:[e]}}}));const o=this._cells=Object.values(t),n=C[this.aggregation]||C.sum;return o.forEach((e=>{e.value=n(e.points)})),o}}class y{_apply(e){}}class b extends i{constructor(){super(...arguments),this._grid=new f,this._point=new y}_doApply(e){super._doApply(e),this._mode=e.mode||"grid",this._grid._apply(e.grid||{}),this._point._apply(e.point||{})}_createPoint(e){return new m(e)}setCalcedColor(e,t){super.setCalcedColor(e,t),this._colorObj=new s(this._calcedColor)}getColorScale(){return 0}getValueRange(){return{min:this._minValue,max:this._maxValue}}getRangedColor(e){if(this._colorRanger)return this._colorRanger.getColor(this._minValue,this._maxValue,e.value,this._colorObj)}initPoints(e){const t=this._orgPoints=super.initPoints(e);if("grid"===this._mode){const e=this._grid.buildCells(t);t.length=0,e.forEach(((e,i)=>{const s=new m;s.index=i,s.coord=[e.lon,e.lat],s.value=e.value,s.cell=e,t.push(s)}))}return t}_doPrepareRender(e,t){var i;super._doPrepareRender(e,t);const s=this._visPoints,{min:r,max:l}=this._calcMinMax(s);this._minValue=r,this._maxValue=l,this._colorRanger=null===(i=e.getColorScale(this.getColorScale()))||void 0===i?void 0:i.getRanger()}}b.type=e,b.defaults=t(i.defaults,{mode:"grid"});class v extends u{constructor(e){super(e)}renderGrid(e,t){this.setPath(["M",0,0,"L",(e.p2[0]-e.p1[0])*t,0,(e.p2[0]-e.p1[0])*t,(e.p3[1]-e.p2[1])*t,(e.p4[0]-e.p1[0])*t,(e.p4[1]-e.p1[1])*t,"Z"])}renderPoint(e,t){}tooltipColor(){return getComputedStyle(this.dom).fill}}class P extends d{constructor(e){super(e,"rm-heatmap-series",!1,!1);const t=p.createElement(e,"foreignObject");this._pointContainer.appendDom(t),this._pointContainer.add(this._dummy=new p(e,c.POINT_CLASS)),this._dummy.dom.style.display="none",t.appendChild(this._canvas=e.createElement("canvas"))}_createMarkers(e){return new _(e,v)}_doPrepeare(e,t,i){this.$_prepareMarkers(t,t._visPoints)}_doRender(e,t){this.$_layoutMarkers(e,t)}_doReset(){}_runShowEffect(e){e&&g.grow(this)}_doViewRateChanged(e){this.$_layoutMarkers(this.width,this.height)}$_prepareSvgCells(e,t){this._pointContainer.setFill(e._runColor),this._markers.prepare(t.length,((i,s)=>{const r=i.point=t[s].point;this._setPointStyle(i,e,r)}))}$_prepareCanvasCells(e,t){}$_prepareGridMode(e,t){const i=e.chart.getProjection(),s=e._grid.cellWidth/3600,r=e._grid.cellHeight/3600,l=this._cells=[];t.forEach((e=>{if(!e.isNull){const t=[e.lon,e.lat],o=[e.lon+s,e.lat],n=[e.lon+s,e.lat+r],a=[e.lon,e.lat+r];if(i.isVisible(t)||i.isVisible(o)||i.isVisible(n)||i.isVisible(a)){const s=i.projectCoord(t),r=i.projectCoord(o),h=i.projectCoord(n),d=i.projectCoord(a);e.xPos=s[0],e.yPos=s[1],l.push({point:e,p1:s,p2:r,p3:h,p4:d})}}})),e._grid.blur>0?this.$_prepareCanvasCells(e,l):this.$_prepareSvgCells(e,l)}$_renderSvgCells(e){const t=this._scale;this._markers.forEach(((i,s)=>{const r=this._cells[s];i.setVisible(!0),i.renderGrid(r,t),i.trans(r.p1[0]*t,r.p1[1]*-t).rotate(e)}))}$_renderCanvasCells(e,t,i){const s=this.model,r=this._dummy,l=this._canvas,o=l.parentNode,n=l.getContext("2d"),{tx:a,ty:h,scale:d}=this._transInfo,p=this._wBody,c=this._hBody;o.setAttribute("width",p),o.setAttribute("height",c),l.width=p,l.height=c,l.style.width=p+"px",l.style.height=c+"px",n.clearRect(0,0,p,c),n.filter="blur(20px)",this._cells.forEach((e=>{const{p1:t,p2:i,p3:l,p4:o,point:p}=e,c=t[0]+(i[0]-t[0])/2,_=t[1]+(o[1]-t[1])/2,g=(i[0]-t[0]+l[0]-i[0])/2,u=(i[1]-t[1]+l[1]-i[1])/2;this._setPointStyle(r,s,p),n.fillStyle=getComputedStyle(r.dom).fill,n.beginPath(),n.ellipse((c-g/2)*d+a,(_-u/2)*-d+h,2*g*d,2*u*d,0,0,2*Math.PI),n.fill(),n.beginPath(),n.ellipse((c-g/10)*d+a,(_-u/10)*-d+h,1.2*g*d,1.2*u*d,0,0,2*Math.PI),n.fill()})),this.trans(0,0)}$_renderGridMode(e,t,i,s){e._grid.blur>0?this.$_renderCanvasCells(t,i,s):this.$_renderSvgCells(s)}$_preparePointMode(e,t){}$_renderPointMode(e,t){}$_prepareMarkers(e,t){if("point"===e._mode);else this.$_prepareGridMode(e,t)}$_layoutMarkers(e,t){const i=this.model,s=+i.options.rotation||0;if("point"===i._mode);else this.$_renderGridMode(i,e,t,s)}}function $(e){(function(e){return e.Series&&e.SeriesView})(e)&&(e.Series.register(b),e.SeriesView.register([b,P]))}export{b as HeatmapSeries,$ as default};
